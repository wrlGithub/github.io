(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d2383e8"],{ff0b:function(t,l){function s(){var t=function(){var t=this,l=t.$createElement;t._self._c;return t._m(0)},l=[function(){var t=this,l=t.$createElement,s=t._self._c||l;return s("div",{staticClass:"frontmatter-markdown"},[s("h1",[t._v("1.HTML+CSS")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("如何理解HTML语义化？")]),t._v(" "),s("ul",[s("li",[t._v("让人更加容易读懂（增加代码的可读性）")]),t._v(" "),s("li",[t._v("让搜索引擎更容易读懂，有助于爬虫抓取有效信息、seo")]),t._v(" "),s("li",[t._v("在没有CSS样式的情况下页面也能很好的呈现内容结构、代码结构。")])])]),t._v(" "),s("li",[s("p",[t._v("script标签中的defer和async的区别")]),t._v(" "),s("ul",[s("li",[t._v("script 会阻碍HTML的解析")]),t._v(" "),s("li",[t._v("async script：解析HTML的过程进行脚本的异步下载，下载完成之后立即执行。")]),t._v(" "),s("li",[t._v("defer script：完全不会阻碍HTML的解析，解析完成之后再按顺序执行脚本。")])])]),t._v(" "),s("li",[s("p",[t._v("在浏览器地址栏中输入url到请求返回发生什么？")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("输入url之后解析出协议、主机、端口、路径等信息，并构造一个http请求")])]),t._v(" "),s("ul",[s("li",[t._v("强缓存")]),t._v(" "),s("li",[t._v("协商缓存")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("DNS域名解析")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("TCP链接")])]),t._v(" "),s("ul",[s("li",[t._v("三次握手")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"4"}},[s("li",[t._v("http请求")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"5"}},[s("li",[t._v("服务器处理请求并返回HTTP报文。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"6"}},[s("li",[t._v("浏览器渲染页面")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"7"}},[s("li",[t._v("断开TCP链接")])])])])]),t._v(" "),s("li",[s("p",[t._v("两种盒模型")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("标准盒模型、IE盒模型")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("标准盒模型："),s("code",{pre:!0},[s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[t._v("box")]),t._v("-sizing:"),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[t._v("content")]),t._v("-"),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[t._v("box")])])]),t._v(" "),s("p",[t._v("宽度和高度用来设置内容区的大小")])]),t._v(" "),s("li",[s("p",[t._v("IE盒模型："),s("code",{pre:!0},[s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[t._v("box")]),t._v("-sizing："),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[t._v("border")]),t._v("-"),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[t._v("box")])])]),t._v(" "),s("p",[t._v("宽度和高度用来设置整个盒子的可见框大小（即width和height指的是内容区、内边距、边框的大小）")])])])])])]),t._v(" "),s("li",[s("p",[t._v("CSS选择器和优先级")]),t._v(" "),s("p",[s("code",{pre:!0},[t._v("!important > style > "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[t._v("id")]),t._v(" > "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[t._v("class")])])])]),t._v(" "),s("li",[s("p",[t._v("重排（reflow）和重绘（repaint）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("重排：无论通过什么方式影响了元素的几何信息（元素在视口内的位置和尺寸的大小），浏览器需要重新计算元素在视口内的集合属性。")])]),t._v(" "),s("li",[s("p",[t._v("重绘：通过构造渲染树和重排（回流 Layout）阶段，我们知道了那些节点是可见的，以及节点的样式和具体的几何信息(元素在视口的位置和尺寸的大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段叫重绘。")])])])])]),t._v(" "),s("p",[t._v("​\t如何减少重排和重绘？")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("最小化重绘和重排，修改样式的时候通过 css 类名修改或通过 cssText 修改。")])]),t._v(" "),s("li",[s("p",[t._v("批量操作DOM")])]),t._v(" "),s("li",[s("p",[t._v("使用absolute 和 fixed 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显")])]),t._v(" "),s("li",[s("p",[t._v("开启GPU加速，利用css属性transform、will-change 等，比如改变元素的位置，我们使用transform会比使用绝对定位改变其left、top等来的高效，因为他不会出发重排或重绘，transform使得浏览器为元素创建一个GPU图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。")])])])])}];return{render:t,staticRenderFns:l}}const _=s();t.exports={attributes:{},vue:{component:{data:function(){return{templateRender:null}},render:function(t){return this.templateRender?this.templateRender():t("div","Rendering")},created:function(){this.templateRender=_.render,this.$options.staticRenderFns=_.staticRenderFns}}}}}}]);
//# sourceMappingURL=chunk-2d2383e8.76cdd7a7.js.map